<p>I've been developing a multi-origin progressive web application platform for a few years. Recently, I noticed that my component hierarchy was starting to bear a striking similarity to the DNS. All of my progressive web application components had dedicated domain names (which is good practice for isolating PWAs) and the growing list of reusable components needed robust namespacing.</p>
<p>The DNS is a highly familiar global namespace. Using a DNS structure allowed me to place all of my reusable software components into this familiar namespace in a meaningful way. It leverages the intuition we already have for domain names, making my source code easier to parse on first read.</p>
<p>My system demands that all applications be aware of the size and shape of components available at other domains, so that a minimal perfect hash function hosted by any of the applications can quickly produce deep links to any other.</p>
<p>The DNS is a hierarchical, human-readable format that is easy to leverage for addressing software components. For example, a URL (such as <code>"www.ejaugust.com"</code>) can be quickly converted into a runtime reference to a piecewise component in the perfect hash function, such as <code>_.com.ejaugust.www</code> (where <code>_</code> represents the DNS root).</p>
<h2>Structural Decisions</h2>
<p>The root of the component graph for the perfect hash function is the DNS root, which doesn't have a name. I elected to use the <code>_</code> (underscore) because it is a short identifier which almost disappears when one component needs to make an absolute reference to another. For example, an absolute reference to this very note will look like <code>_.com.ejaugust.www.notes["1753855231"]</code>.</p>
<p><code>_</code> is the <em>only</em> global object in the platform. This allows me to not pollute the global scope, while still allowing every component to easily grab any other.</p>
<p>For the sake of consistency, all of the first-level components are top-level domains. While I <em>could</em> have made the first level all apex domains, that would have required something like <code>_.com_ejaugust.www</code> or worse, <code>_.comEjaugust.www</code>, or worst of all, <code>_["com.ejaugust"].www</code>. By making all TLDs into their own components, there is now an opportunity to add distinguishing behavior, which can formalize whatever reason we have for acquiring domain names with certain TLDs.</p>
<p>Naturally, all second-level components are apex domains. This is best employed with simple TLDs like ".com" rather than regional ones like <code>".co.uk"</code> since "co" would be considered a second-level component in this case. This would not be a problem, structurally, but it would break the current pattern in which all second-level software components correspond to owned domain properties.</p>
<p>The third level, then, consists of subdomains of owned properties. The DNS includes A records for both the apex domain and its <code>"www."</code> subdomain. The server uses 301 forwarding to guarantee the presence of the <code>"www."</code> prefix. The result is that all components corresponding to the root of a public web application are consistently and meaningfully named "www". Then, clarity about the purpose and scope of software components in relation to each web application can be achieved by placing the component either in or next to this subdomain.</p>
<p>The deeper we go in the hierarchy, the more specific the components. This presented me with a number of challenges. Namely, that some components were shared across all PWAs but needed to be arbitrarily nested for organizational purposes. To resolve this, I purchased the domains <code>"core.parts"</code>, <code>"user.parts"</code> and <code>"desktop.parts"</code>. This allows me to access these shared components by absolute reference via the <code>_.parts</code> component. It also gives me three cool domains (in my humble opinion) at which to host interesting PWAs.</p>
<p>The <code>"core.parts"</code> component houses mostly abstract components, prototype objects which act as base classes for all other components in the system. These abstracts define the system's MVC architecture, handling the arithmetic of the minimal perfect hash function under the hood.</p>
<p>Conversely, <code>"desktop.parts"</code> becomes the namespace for bootstrapping the operating system style graphical user interface that I want my platform to employ. <code>"user.parts"</code> is not currently being used. I am still brainstorming about its purpose and potential. Originally, I had plans for it which were later changed, so I'm just hanging on to it.</p>
<h2>Potential DNS Configuration Tie-in</h2>
<p>Imagine that not all of the domain properties in my platform were owned by me, or that I had multiple separate deployments of my platform for different clients. Having all of the components hosted on the DNS means that property owners can potentially configure certain aspects of the platform by adding records to the DNS which the application can resolve at boot time.</p>
<p>A perfect example of this is modifying the "landing hash" of a given domain. In my platform, all URLs are versioned in order to protect previously shared and bookmarked links from changes in the format used for generating permalinks while giving me flexibility to completely redefine the hash scheme later. When fetching the empty path, such as <code>"https://www.ejaugust.com/"</code>, we redirect to a versioned URL. This gives us an opportunity during that redirect to assign a default landing hash - the state the system should occupy when the program first loads. This landing hash could be assigned to a TXT record and the exact 301 destination can be resolved at request-time.</p>
<h2>Conclusion</h2>
<p>The added structure mirrors the way organizational data is already organized in a cross-origin scenario. Making the pattern explicit brings clarity, extensibility, and opportunities for shared tooling. It also makes the code more readable and easy to understand. I don't need to learn anything new to understand that <code>_.com.ejaugust.www.notes</code> refers to the notes subcomponent of this website.</p>
<p>The DNS is a powerful and familiar abstraction. At first glance, we immediately know what we're looking at when we see a domain name. A cross-origin multi-PWA deployment, especially one that allows cross-site deep linking the way that this project does, already demands a component structure that closely aligns with the DNS. By combining them, we remove cognitive friction, improving the ergonomics of the platform from a development perspective and opening the door to further opportunities.</p>
<p>There are many opportunities, too. I won't get into them here, and I may write about them later, but it isn't hard to imagine how this alignment can be leveraged. Thanks for reading! I look forward to writing more about the project later.</p>