<p>Most web platforms can get away with a hidden service worker update. When the server pushes a new version, the browser's service worker automatically updates, and the old version of the app is replaced with the new. This works because user state is typically managed on the server.</p>
<p>But for a platform like kireji, a simple update can be catastrophic. The application’s state is encoded in its URL using a perfect hash function. A perfect hash function requires that the hashed domain be known before hashes can be generated. By changing even just a few elements, the generated hashes can be dramatically different. A single off-by-one error is enough to cause data loss.</p>
<p>So what happens when I want to add a bunch of fun new features to the application? The state space changes dramatically, resulting in a new hash domain and range. This means a completely new, incompatible hash function. A naive update would lead to:</p>
<ul>
 <li>Corrupted data for active users: a user on an older version of the application might see their active session become corrupted as soon as the service worker updated in the background. The new hash function wouldn't be able to decode their current URL.</li>
 <li>Broken bookmarks: all of the shared links and bookmarks that had ever been made from the platform would become broken links lead to arbitrary, unwanted states. This violates the whole purpose of a "permanent link", putting the founding principals of this platform - that it offers a permalink to every state - on shaky ground.</li>
</ul>
<h2>A Naive Solution and Its Limitations</h2>
<p>A common, albeit flawed, solution to this problem is to include legacy support for previous versions of the hash function in the new service worker. The system could retain older versions of the compression model within the latest build, allowing the new service worker to decode old URLs.</p>
<p>However, this "legacy support" hack is a stopgap with significant costs:</p>
<ul>
 <li>The service worker's file size would increase with every major update, as it would have to carry the weight of all previous compression models. This would lead to slower load times for every user, regardless of their Browse history.</li>
 <li>The codebase would become tangled with multiple versions of the hashing logic, creating a maintenance nightmare and increasing the likelihood of bugs.</li>
 <li>It would be very difficult to tell which versions of the hash function to keep and which versions to throw away. For the users who don't need this legacy support, they still bear the cost of downloading and storing the extra code.</li>
</ul>
<h2>Kireji's Update Strategy</h2>
<br>This platform embraces a user-controlled philosophy inspired by the behavior of an operating system.</p>
<p>In Windows, for example, the upgrade from Windows 10 to Windows 11 is not an automatic, server-driven event. If it was, it would probably trigger a massive infrastructure failure across a ton of industries. Instead, operating systems allow these updates to be user-initiated. This puts users in control of the integrity of their data.</p>
<p>On this platform, the server's role is minimal: it has an endpoint that provides the latest version number and a URL template that an older client can use to generate an update URL. The server provides a template so that we have the flexibility to change the URL format later, older clients can still perform an update.</p>
<p>The service worker and progressive web app are both scoped to a versioned path. The hash function is stored in the service worker. The server maintains previous versions of the service worker with a versioned name. That way, permalinks with a version number correspond to that version of the service worker.</p>
<p>A client-side update manager orchestrates a multi-step, user-initiated update process. The client checks the update endpoint. If the version is newer than the client, it presents a button to "Upgrade to [latest version here]". When the user clicks the button, the client enters an "upgrading" state. This update is a two-step process blended together by a CSS transition:</p>
<ol>
 <li>The old version of the application serializes its state as JSON and stores it in localStorage using a unique nonce URL as a key. This format is far larger than the compressed format used to store the state within a URL, but it's in a format that the new version of the platform can understand even if they use a different hash function. A half-second before the client navigates into the new worker's scope, an opaque UI layer fades in to show an "Upgrading..." message.</li>
 <li>The client then navigates into the new scope. If the new service worker isn't already installed, it happens now. The new version is a blank slate; it doesn't know exactly what to show the user until it read the data in localStorage. So, the server presents a page with the same opaque UI layer with no visible change, making the navigation feel seamless for the user. During hydration, the new client retrieves the old state from localStorage, performs the necessary data migration from the old compression model to the new one, and then cleans up the localStorage entry. Then, the overlay fades away to reveal the latest version - with all of the user's data already set.</li>
</ol>
<p>This effectively translates hashes between two hash functions without either of them having to know about the other. Because it is handled as a page navigation, the user can use the back button in their browser to return to the moment before the upgrade. If the user wants to keep the new version, they'll have to manually update any bookmarks as these will still be pointed to the old version's scope.</p>
<h3>Coming Soon: The Data Integrity Modal</h3>
<p>The final piece to the puzzle will be to show a "Data Integrity Report" modal after an update. Properties can only be transferred if they have the same name in both versions. Users might like to know what did and didn't transfer.</p>
<p>This modal will allow users to manually reconcile data points that weren't automatically transitioned by the upgrade process. This will make the update process a hands-on experience.</p>
<h2>Conclusion</h2>
<p>This client-side update strategy avoids the pitfalls of packing older versions of the system's compression algorithm into a new version and performs the migration on the client, reducing the burden on the server. By using a user-initiated update process, we are able to give users full control over their service worker versioning. This reinforces the notions that a.) we're treating the user's current URL as a file that shouldn't be reset or erased and b.) each version of the platform is a stand-alone, installed piece of software rather than a volatile website.</p>
<p>It also gives us carte blanch to make breaking changes to the application’s hash function. It brings the current interface more in-line with my long-term goal of creating a website that feels like an operating system and offers a URL to every state.</p>