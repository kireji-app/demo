<p>Most web platforms can get away with a hidden service worker update. When the server pushes a new version, the browser's service worker automatically updates, and the old version of the app is replaced with the new. This works because user state is typically managed on the server.</p>
<p>But for a platform like kireji, a simple update can be catastrophic. The application’s state is encoded in its URL using a perfect hash function. A perfect hash function requires that the hashed domain be known before hashes can be generated. By changing even just a few elements, the generated hashes can be dramatically different. A single off-by-one error is enough to cause data loss.</p>
<p>So what happens when I want to add a bunch of fun new features to the application? The state space changes dramatically, resulting in a new hash domain and range. This means a completely new, incompatible hash function. A server-driven update would lead to:</p>
<ul>
 <li>Corrupted data for active users: a user on an older version of the application might see their active session become corrupted as soon as the service worker updated in the background. The new hash function wouldn't be able to decode their current URL.</li>
 <li>Broken bookmarks: all of the shared links and bookmarks that had ever been made from the platform would become broken links and lead to arbitrary, unwanted states. This violates the whole purpose of a "permanent link", putting the founding principals of this platform - that it offers a permalink to every state - on shaky ground.</li>
</ul>
<h2>A Naive Solution And Its Limitations</h2>
<p>One solution to this problem would be to include legacy support for previous versions of the hash function in the latest version of the platform, allowing the new service worker to decode old URLs. However, this method comes with significant costs:</p>
<ul>
 <li>The service worker's file size will increase with every major update, as it would have to carry the weight of all previous compression models. For users who don't need legacy support, they have to download it anyways.</li>
 <li>The codebase would become less manageable as multiple versions of the hashing logic add up, creating a maintenance nightmare and increasing the likelihood of bugs.</li>
 <li>It would be very difficult to tell which versions of the hash function are worth keeping and which versions to throw away.</li>
</ul>
<p style="color: orange;">On this platform, the service worker and progressive web app are scoped to a versioned path. The hash function is stored in the service worker. The server maintains previous versions of the service worker with a versioned name. That way, permalinks with a version number are in the scope of that version of the service worker. The server has a simple endpoint that provides the latest version number and a URL template. All client versions are welcome to fetch this endpoint to see if a newer version is out. In addition to the version number, the server also provides a URL template that clients can use to generate a nonce URL that is guaranteed to navigate into the scope of the latest version and outside the scope of the current version. Using a server-provided URL template gives me the flexibility to change the URL format later without breaking the update process for older clients. If the version is newer than the client, it presents a button to "Upgrade to [latest version here]". When the user clicks the button, the client enters an "upgrading" state.</p>
<h2 style="color: green;">Two-Version Methods</h2>
<p style="color: green;">I experimented with two versions of an upgrade feature which behave almost exactly the same from the end-user perspective except for some minor details of polish and their interaction with bfcache. They both use two separate versions of the hash function, generating an intermediate model with a source version and passing that model to a destination version to generate a hash. One takes place on the client and one takes place on the server. Ultimately, I chose the server-side translation method for a few reasons.</p>
<h3>Client-Side Translation</h3>
<p style="color: green;">I designed this method in order to take the pressure off of the very low-end server I'm using but that it ultimately still required server-side interaction in order to fetch and install the latest version of the hash function anyways.</p>
<p style="color: green;">In the client-side translation model, when the user clicks the upgrade button, upgrading is a two-step process blended together by a CSS transition:</p>
<h4 style="color: orange;">Transition Away From The Old Version</h4>
<p style="color: orange;">The old version of the application generates a nonce URL from the template, serializes all of its model data as JSON and stores it in localStorage using the nonce as a key. This way of serializing the data is far larger and less efficient than the perfect hash format I use when I store that state as a URL, but this JSON data is readable by all versions of the platform, even if they have a wildly different hash domain.</p>
<p style="color: orange;">A half-second before the client navigates into the new scope, an opaque UI layer fades in and shows an "Upgrading..." message.</p>
<h4 style="color: orange;">Transition Into The New Version</h4>
<p style="color: orange;">The client navigates into the new scope. The new version is a blank slate; it doesn't know exactly what to show the user until it reads the data in localStorage. I won't send the full JSON data to the server, meaning that the server can't render the exact HTML and CSS that the user should see when the upgrade is complete. So, the server renders a page with the same opaque UI layer and "Upgrading..." message as the previous version. If the latest service worker isn't already installed, that happens now. With no blink or empty frame during navigation, the upgrade appears seamless to the user.</p>
<p style="color: orange;">During hydration, the new client retrieves the old state from localStorage, performs the necessary data migration from the old compression model to the new one, and then cleans up the localStorage entry. Then, the overlay fades away to reveal the latest version - with all of the user's data already set.</p>
<p style="color: orange;">A major drawback of this client-side method was that it only allowed upgrading to the latest version, not to any other specific version.</p>
<h3>Server-Side Translation</h3>
<p style="color: green;">In the server-side translation model, when the user clicks the upgrade button, I have now moved to a server-side redirect approach. While the client-side translation was effective, it had a few limitations I needed to address. It was difficult to manage the browser's back-forward cache (bfcache) without a loading indicator, which disrupted the seamless user experience. I also wanted to allow users to gracefully "undo" an update, which is difficult with client-side state changes. This new method allows for a clean "undo" with the browser's back button and also allows for a much more graceful transition with the bfcache. Another benefit of this approach is that it allows for converting a hash from any hash function version to any other, making upgrading and downgrading possible. The client simply sends a url like "&lt;origin&gt;/&lt;target version&gt;/&lt;old version hash&gt;/?from=&lt;old version&gt;" and the server performs a 302 redirect to "&lt;origin&gt;/&lt;target version&gt;/&lt;new version hash&gt;/".</p>
<h2 style="color: green;">Coming Soon: The Data Integrity Modal</h2>
<p style="color: orange;">The final piece to the puzzle will be to show a "Data Integrity Report" modal after an update. Properties can only be transferred if they have the same name in both versions. Users might like to know what did and didn't transfer.</p>
<p style="color: orange;">This modal will allow users to manually reconcile data points that weren't automatically transitioned by the upgrade process. This will make the update process a hands-on experience.</p>
<h2 style="color: green;">Conclusion</h2>
<p style="color: green;">This server-side update strategy avoids the pitfalls of packing older versions of the system's compression algorithm into a new version and performs the migration on the server. By using a user-initiated update process, I am able to give users full control over their service worker versioning. This reinforces the notions that a.) I'm treating the user's current URL as a file that shouldn't be reset or erased and b.) each version of the platform is a stand-alone, installed piece of software rather than a volatile website.</p>
<p style="color: green;">It also gives me carte blanch to make breaking changes to the application’s hash function. It brings the current interface more in-line with my long-term goal of creating a website that feels like an operating system and offers a URL to every state.</p>