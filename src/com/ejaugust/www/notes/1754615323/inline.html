<p>Most web platforms can get away with a hidden service worker update. When the server pushes a new version, the browser's service worker automatically updates, and the old version of the app is replaced with the new. This works because user state is typically managed on the server.</p>
<p>But for a platform like kireji, a simple update can be catastrophic. The application’s state is encoded in its URL using a perfect hash function. A perfect hash function requires that the hashed domain be known before hashes can be generated. By changing even just a few elements, the generated hashes can be dramatically different. A single off-by-one error is enough to cause data loss.</p>
<p>So what happens when I want to add a bunch of fun new features to the application? The state space changes dramatically, resulting in a new hash domain and range. This means a completely new, incompatible hash function. A server-driven update would lead to:</p>
<ul>
 <li>Corrupted data for active users: a user on an older version of the application might see their active session become corrupted as soon as the service worker updated in the background. The new hash function wouldn't be able to decode their current URL.</li>
 <li>Broken bookmarks: all of the shared links and bookmarks that had ever been made from the platform would become broken links and lead to arbitrary, unwanted states. This violates the whole purpose of a "permanent link", putting the founding principals of this platform - that it offers a permalink to every state - on shaky ground.</li>
</ul>
<h2>A Naive Solution and Its Limitations</h2>
<p>One solution to this problem would be to include legacy support for previous versions of the hash function in the latest version of the platform, allowing the new service worker to decode old URLs. However, this method comes with significant costs:</p>
<ul>
 <li>The service worker's file size will increase with every major update, as it would have to carry the weight of all previous compression models. For users who don't need legacy support, they have to download it anyways.</li>
 <li>The codebase would become less manageable as multiple versions of the hashing logic add up, creating a maintenance nightmare and increasing the likelihood of bugs.</li>
 <li>It would be very difficult to tell which versions of the hash function are worth keeping and which versions to throw away.</li>
</ul>
<h2>Kireji's Update Strategy</h2>
<p>This platform considers "updates" as "upgrades" to the latest version. For example, the upgrade from Windows 10 to Windows 11 is not an automatic, server-driven event. That would probably damage a ton of infrastructure. Instead, it's user-initiated. The administrator of the system is in control of data integrity.</p>
<p>This platform works the same way. waits for users to manually request an upgrade. To do this, the service worker and progressive web app are scoped to a versioned path. The hash function is stored in the service worker. The server maintains previous versions of the service worker with a versioned name. That way, permalinks with a version number are in the scope of that version of the service worker.</p>
<p>The server has a simple endpoint that provides the latest version number and a URL template. All client versions are welcome to fetch this endpoint to see if a newer version is out. In addition to the version number, the server also provides a URL template that clients can use to generate a nonce URL that is guaranteed to navigate into the scope of the latest version and outside the scope of the current version. Using a server-provided URL template gives us the flexibility to change the URL format later without breaking the update process for older clients.</p>
<p>If the version is newer than the client, it presents a button to "Upgrade to [latest version here]". When the user clicks the button, the client enters an "upgrading" state. Upgrading is a two-step process blended together by a CSS transition:</p>
<h3>Transition Away from the Old Version</h3>
<p>The old version of the application generates a nonce URL from the template, serializes all of its model data as JSON and stores it in localStorage using the nonce as a key. This way of serializing the data is far larger and less efficient than the perfect hash format we use when we store that state as a URL, but this JSON data is readable by all versions of the platform, even if they have a wildly different hash domain.</p>
<p>A half-second before the client navigates into the new scope, an opaque UI layer fades in and shows an "Upgrading..." message.</p>
<h3>Transition Into the New Version</h3>
<p>The client navigates into the new scope. The new version is a blank slate; it doesn't know exactly what to show the user until it reads the data in localStorage. We won't send the full JSON data to the server, meaning that the server can't render the exact HTML and CSS that the user should see when the upgrade is complete. So, the server renders a page with the same opaque UI layer and "Upgrading..." message as the previous version. If the latest service worker isn't already installed, that happens now. With no blink or empty frame during navigation, the upgrade appears seamless to the user.</p>
<p>During hydration, the new client retrieves the old state from localStorage, performs the necessary data migration from the old compression model to the new one, and then cleans up the localStorage entry. Then, the overlay fades away to reveal the latest version - with all of the user's data already set.</p>
<p>This effectively translates hashes between two hash function versions without either of them having to know the arithmetic that powers the other. Because it is handled as a page navigation, the user can hit the back button in their browser to return to the moment before the upgrade. If they want to keep the new version, they can manually update any bookmarks that are still pointing to a page inside the old worker's scope.</p>
<h3>Coming Soon: The Data Integrity Modal</h3>
<p>The final piece to the puzzle will be to show a "Data Integrity Report" modal after an update. Properties can only be transferred if they have the same name in both versions. Users might like to know what did and didn't transfer.</p>
<p>This modal will allow users to manually reconcile data points that weren't automatically transitioned by the upgrade process. This will make the update process a hands-on experience.</p>
<h2>Conclusion</h2>
<p>This client-side update strategy avoids the pitfalls of packing older versions of the system's compression algorithm into a new version and performs the migration on the client, reducing the burden on the server. By using a user-initiated update process, we are able to give users full control over their service worker versioning. This reinforces the notions that a.) we're treating the user's current URL as a file that shouldn't be reset or erased and b.) each version of the platform is a stand-alone, installed piece of software rather than a volatile website.</p>
<p>It also gives us carte blanch to make breaking changes to the application’s hash function. It brings the current interface more in-line with my long-term goal of creating a website that feels like an operating system and offers a URL to every state.</p>