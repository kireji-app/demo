<p>A web application's update process is often a mundane affair. The server pushes a new version, a new service worker takes over, and the user continues on their way, none the wiser. This approach works perfectly well for most sites where data is handled by a server and there aren't any significant routing changes. But what happens when the application's routing system is volatile?</p>
<p>This was the central challenge for kireji, a platform that uses stateful routing with perfect hashing to embed application state directly into URLs. A new service worker, with a different data compression model, would instantly break all old bookmarks and active user sessions. To solve this, we needed an update strategy that prioritized data integrity and user control above all else.</p>
<h2>The Peril of Data-Centric Routing</h2>
<p>Most web platforms can get away with a hidden service worker update. When the server pushes a new version, the browser's service worker automatically updates, and the old version of the app is replaced with the new. This works because user state is typically managed on the server.</p>
<p>But for a platform like kireji, a simple update can be catastrophic. The application’s state is encoded in its URL using a perfect hash function. A perfect hash function requires that the hashed domain be known before hashes can be generated. By changing even just a few elements, the generated hashes can be dramatically different. A single off-by-one error is enough to cause data loss.</p>
<p>So what happens when I want to add a bunch of fun new features to the application? The state space changes dramatically, resulting in a new hash domain and range. This means a completely new, incompatible hash function. A naive update would lead to:</p>
<ul>
 <li>Corrupted data for active users: a user on an older version of the application might see their active session become corrupted as soon as the service worker updated in the background. The new hash function wouldn't be able to decode their current URL.</li>
 <li>Broken bookmarks: all of the shared links and bookmarks that had ever been made from the platform would become broken links lead to arbitrary, unwanted states. This violates the whole purpose of a "permanent link", putting the founding principals of this platform - that it offers a permalink to every state - on shaky ground.</li>
</ul>
<h2>A Naive Solution and Its Limitations</h2>
<p>A common, albeit flawed, solution to this problem is to include legacy support for previous versions of the hash function in the new service worker. The system could retain older versions of the compression model within the latest build, allowing the new service worker to decode old URLs.</p>
<p>However, this "legacy support" hack is a stopgap with significant costs:</p>
<ul>
 <li>The service worker's file size would increase with every major update, as it would have to carry the weight of all previous compression models. This would lead to slower load times for every user, regardless of their Browse history.</li>
 <li>The codebase would become tangled with multiple versions of the hashing logic, creating a maintenance nightmare and increasing the likelihood of bugs.</li>
 <li>It would be very difficult to tell which versions of the hash function to keep and which versions to throw away. For the users who don't need this legacy support, they still bear the cost of downloading and storing the extra code.</li>
</ul>
<h2>A Client-Side Solution: Kireji's Update Strategy</h2>
<br>For this platform, the solution moves beyond these naive approaches by embracing a client-centric, user-controlled philosophy inspired by the behavior of an operating system.</p>
<p>In Windows, the upgrade from Windows 10 to Windows 11 is not an automatic, server-driven event. If it was, then Microsoft might accidentally trigger a massive infrastructure failure across a ton of industries. Instead, operating systems allow these updates to be user-initiated. This puts users in control of the integrity of their data.</p>
<p>In the case of this platform, the server's role is minimal: it simply provides the latest version number and a nonce template that any older client can use to generate an update URL that is compatible with the latest server version - even if later versions of the function decide to change the format of its update nonces.</p>
<p>Previously published versions of the service worker and hash function are retained with a version number which is reflected in the URL of all permalinks. The service worker and progressive web app manifest are both carefully scoped according to the versioned URL scheme. A client-side update manager orchestrates a multi-step, user-initiated update process. Previously published versions of the service worker are still retained on the server, so that bookmarks and shared links retain their same meaning.</p>
<h3>User-Initiated Roll-Over</h3>
<p>So how does the data actually roll-over from one version to the next? Well, I'll tell you!</p>
<p>The client checks for updates. If a newer version is available, the client presents a button to "Upgrade to [latest version here]". When the user clicks this button, the client enters a unique update mode. This update is a two-step process disguised as a single button click:</p>
<ol>
 <li>The old version of the application serializes its entire application state into localStorage using a unique nonce URL as a key. This ensures that the <em>fully uncompressed, unhashed</em> data model is preserved.</li>
 <li>The client then navigates to the nonce URL, which will be outside the scope of the previous version's service worker and progressive web app. If it hasn't already been downloaded and installed, the new service worker with the latest version of the application loads.</li>
</ol>
<p>Both the server and the client recognize the nonce URL. This allows the server-rendered page to present the "Upgrading..." interface as the new client installs. The new client retrieves the old state from localStorage, performs the necessary data migration from the old compression model to the new one, and then cleans up the localStorage entry.</p>
<p>Until the new client ingests the old client's state, the new version doesn't know exactly what to present to the user. For example, was the user in light mode, dark mode or device mode? Were they using the modern look-and-feel or did they opt for vintage mode?</p>
<p>To smooth over this transition, the framework uses CSS to hide the UI during data migration. A half-second before the client navigates to the nonce URL, an opaque UI layer fades in to show an "Upgrading..." message. The server-rendered page (or worker-rendered, if the user is upgrading to an old bookmarked page to a new version they've already installed) represents the new version of the application and already bears the same overlay. The UI remains inert until the migration is complete and the new version has ingested the old data model. Then, the overlay fades away to reveal the latest version - hopefully with all of the user's data in-tact.</p>
<h3>The Future of Data Integrity and User Control</h3>
<p>The final piece of our strategy is to move beyond simply a seamless update to one that is truly user-centric. While the current system is robust, it lacks transparency. Any model properties that changed their name between the old and new version are simply discarded. Only the same-named properties are adopted by the new version.</p>
<p>The good news is, the user can always click back in their browser to undo the upgrade. They can also revisit to an old bookmarked link to return to the old version and recover their old data. Still, to truly make data integrity a priority, the plan is to include a "Data Integrity Report" modal that will be presented to the user after an update.</p>
<p>This modal would empower the user to:</p>
<ul>
 <li>See a side-by-side view of their data, detailing any changes or data loss that occurred during the migration.</li>
 <li>Manually reconcile data from the old model that couldn't find a home in the new version.</li>
</ul>
<p>This feature will turn the update process into a hands-on process that provides the user with control and transparency over their data.</p>
<h2>Conclusion</h2>
<p>This client-side update strategy completely avoids the pitfalls of naive updates by offloading the data migration burden from the server. By prioritizing user-initiated actions, a well-defined API contract, and a clever localStorage-based data migration, we've created an update process that puts full control over service worker versioning into the client-side GUI.</p>
<p>This ensures a smooth, secure, and transparent update process that is resilient to breaking changes in the application’s core data model. It also brings the current interface more in-line with my long-term goal of creating a web app that feels like an operating system but which offers a URL to every possible state.</p>