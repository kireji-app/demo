<p>In a traditional fixed-length base-64 string of length <math><mi>n</mi></math>, you can represent <math><msup><mn>64</mn><mi>n</mi></msup></math> unsigned integers, corresponding to the range:</p>
<math display="block"><mrow><mo>[</mo><mn>0</mn><mo>,</mo><msup><mn>64</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><mo>[</mo><mn>0</mn><mo>,</mo><msup><mn>64</mn><mi>n</mi></msup><mo>)</mo></mrow></math>
<p>But when you allow <em>variable-length strings</em> (including the empty string), each additional character position opens up a whole new tier of representable values. The total number of distinct encodable integers using up to <math><mi>n</mi></math> characters is computed by this geometric series:</p>
<math display="block"><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msup><mn>64</mn><mi>k</mi></msup></mrow><mo>=</mo><mfrac><mrow><msup><mn>64</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><mn>63</mn></mfrac></math>
<p>We can expand <math display="inline"><mfrac><mrow><msup><mn>64</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>-</mo><mn>1</mn></mrow><mn>63</mn></mfrac></math> as:</p>
<math display="block"><mfrac><mrow><msup><mn>64</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>-</mo><mn>1</mn></mrow><mn>63</mn></mfrac><mo>=</mo><mn>1</mn><mo>+</mo><mn>64</mn><mo>+</mo><msup><mn>64</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mn>64</mn><mi>n</mi></msup></math>
<p>By comparing this to the first expression, we can see that:</p>
<math display="block"><msup><mn>64</mn><mi>n</mi></msup><mspace width="1em"></mspace><mo><</mo><mspace width="1em"></mspace><mo>(</mo><mn>1</mn><mo>+</mo><mn>64</mn><mo>+</mo><msup><mn>64</mn><mn>2</mn></msup><mo>+</mo><mo>…</mo><mo>+</mo><msup><mn>64</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>)</mo><mo>+</mo><msup><mn>64</mn><mi>n</mi></msup></math>
<p>The second expression is equal to the first <em>plus a bunch of positive terms</em> <math display="inline"><mn>1</mn><mo>+</mo><mn>64</mn><mo>+</mo><mo>&#x2026;</mo><mo>+</mo><msup><mn>64</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></math>, making it larger than <math display="inline"><msup><mn>64</mn><mi>n</mi></msup></math> alone. That added information is encoded by the <em>string's length</em>.</p>
<p>Another way to think of this is that your typical numeral permits leading zeros, meaning that <code>"12"</code> is equal to <code>"012"</code> is equal to <code>"0012"</code>, etc. Using a bijective base-64 encoding, each string of characters maps uniquely to a natural number. Leading zeros are therefore not semantically void. Because <code>"12"</code>, <code>"012"</code> and <code>"0012"</code> are different strings, they represent different integers.</p>