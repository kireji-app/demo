<p>In the Kireji Web Framework, a canonical URL is a short, human-readable URL that defines an override for the state of the ecosystem compared to the default landing hash (or the current state the client is in).</p>
<p>This allows Kireji's atypical routing system to feature the same behavior as a typical website: the ability to have simple, unversioned links like:</p>
<pre>https://example.com/my-favorite-page</pre>
<p>Because these URLs lack query parameters, they lack composition (multiple URLs can't be combined deterministically into a merged form). This means that they aren't as comprehensive as Kireji's own hash routing system. It also means that only one override to the state can be defined per canonical URL. This simplifies and constrains the translation behavior in Kireji.</p>
<h2>URL Structure</h2>
<p>Canonical URLs are composed of just two parts: an origin</p>
<pre>https://example.com</pre>
<p>and a pathname</p>
<pre>/my-favorite-page</pre>
<p>Kireji URLs, on the other hand, are composed of three parts: an origin, an ecosystem version number, and a state hash.</p>
<pre>https://example.com/1.2.3/aurg3248gh23rg-234rfwrv_asdf</pre>
<p>The challenge for canonical URLs is to design a translation service that turns canonical URLs into Kireji URLs.</p>
<p>Luckily, the origin is easy for the server to handle: its the same for both URLs and features the domain name being used to access the server. Adding the version number is also trivial: all canonical links point to the latest LTS version of the ecosystem which happens to be the current version of the server.</p>
<p>So, the main task for the translation service is really just converting a human-readable pathname into a stateful hash.</p>
<p>In Kireji, hashes are cross-origin and mean the same thing across all host names. For example:</p>
<pre>https://<b>aaaa</b>.example.com/1.0.0/24rtgetb</pre>
<p>is the same data as</p>
<pre>https://<b>bbbb</b>.example.com/1.0.0/24rtgetb</pre>
<p>just viewed from a different app. In contrast, canonical paths mean something different for each origin.</p>
<pre>https://<b>store</b>.example.com/<b>red-shirt</b></pre>
<p>is not the same thing as</p>
<pre>https://<b>star-trek-characters</b>.example.com/<b>red-shirt</b></pre>
<p>That needs to be taken into consideration for the translation logic.</p>
<h2>URL-as-a-File Metaphor</h2>
<p>The routing model for a Kireji ecosystem can be thought of as a file type spec, such that Kireji URLs can be thought of as highly compressed, lossless save files. These files have a simple structure: a small header provides the origin (indicating the application that is currently full-screened) and version number of the file spec. This is then followed by the file body: a block of data which achieves the information-theoretic lower bound for data compression according to the file spec.</p>
<p>This is analogous to how common file types such as GIF feature a small header with meta data followed by blocks of data representing the file.</p>
<p>Under this metaphor, canonical URLs are a bit strange - the equivalent of having a GIF spec that includes a handful of predefined GIFs which can be accessed by simply writing their name as plain text and giving the file a <b>.gif</b> extension. All GIF readers would then have to store a table containing all these premade GIFs according to their name.</p>
<p>This would be unusual behavior for a file type like GIF, but its expected behavior when fetching web URLs.</p>
<h2>Use Cases for Canonical URLs</h2>
<p>Critically, canonical links have two use cases in Kireji:</p>
<ol>
 <li>External Linking
  <ul>
   <li>This is their main purpose: providing familiar, marketing-friendly links like ad-click links and search engine results.</li>
   <li>These need to be unversioned and human-readable. This makes them easy to type, understand and share.</li>
   <li>The server needs to be able to translate these into versioned Kireji URLs so we know exactly what file they represent.</li>
  </ul>
 </li>
 <li>Internal Linking
  <ul>
   <li>Any anchor links <i>inside</i> Kireji web apps (including any sitemap) will get indexed by search engines and become external links, so we don't want to see this anywhere in the web app's source code:
    <pre>&lt;a href="https://example.com/1.0.0/4gw5-g5wnzzw35h4g"&gt;Click here&lt;/a&gt;</pre>
   </li>
   <li>Besides, rendering versioned anchor links inside app HTML would be annoying and not straightforward - link elements would need to be tracked and their <code>href</code> attributes updated every time the ecosystem state changed. This would cause an explosion of URLs that would confuse search engine spiders.</li>
   <li>
    Hovering over links helps desktop users gain additional context about where the link will go. This doesn't look like anything to the user:
    <pre>https://example.com/1.0.0/4gw5-g5wnzzw35h4g</pre>
    Whereas this is clear:
    <pre>https://example.com/contact-us</pre>
   </li>
   <li>As is common in web apps, anchor tags require <code>onclick</code> handlers to interrupt internal link clicks in order to update <i>parts</i> of the page without navigating away. In Kireji, this is even more important to retain file data encoded in the URL hash.</li>
  </ul>
 </li>
</ol>
<p>Given the usefulness and requirements of canonical URLs both internally and externally, the canonical link translator has the opportunity to kill two birds with one stone:</p>
<ol>
 <li>It can enhance search engine optimization and the first arrival experience.</li>
 <li>It creates a URL language that tells the client exactly what aspect of the current file a given anchor link is meant to change (making canonical URLs behave more like <i>tools</i> than <i>destinations</i>) without having to encode that behavior separately in the onclick handler.</li>
</ol>
<p>Different versions of the ecosystem will still function correctly even if they support different canonical URLs but there are two complications introduced by versioning:</p>
<ol>
 <li>A canonical URL that was hard-coded into an old version may not be supported several versions later. Older versions of the ecosystem should thus avoid being indexed by search engines.</li>
 <li>The fact that an unsupported canonical URL still works on an old versioned page may confuse some users. This could happen if, for example, the user notes a URL while hovering over a link and sees that it works when clicked but not when shared. This is a rare edge case however, and its a risk that we can accept right now.</p>
</ol>
<h2>Final Translation Methodology</h2>
<p>After breaking down these use cases, the optimal implementation is one where canonical URLs represent a <b>delta or tool</b> which describes a change-of-state to the base state. When linking internally, that base state is the current versioned URL hash. When coming into the ecosystem from an external link, that base state is the <b>default landing hash</b>.</p>
<p>These delta operations must account for the need to both <b>set</b> and <b>unset</b> state parameters. For example, the empty pathname (e.g. <code>https://example.com/</code>) most likely represents a home page, which is probably the default landing state and so the delta shouldn't need to do anything. In contrast, linking to <code>https://example.com/</code> from <code>https://example.com/1.0.0/gr224-245g-435</code> may require hiding an article and then redrawing the home page. So, canonical URLs represent functional but <i>idempotent</i> tools.</p>