return `<p>For a few years I've been working on a method of building a reactive, component-based web framework wherein each component (including nested components) can store its runtime state in the routing system.
<p>Some of my early attempts involved query parameters, base64-encoded JSON objects, domain-specific languages, and my own custom syntax. They all had the same problem - they failed to capitalize on the <i>actual space available in URLs</i>.</p>
<p>An incredible combinatorial explosion appears when you try to compute the number of unique URLs that can exist. Query params, JSON objects, domain-specific languages and custom syntax all encode redundant information and require extra characters for namespacing and delimiters that take up space in the URL. They also make handling nested component states a nightmare.</p>
<p>The Solution: MPHF</p>
<p>A <a ${_.pointAttr()} class="external" href="https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function">minimal perfect hash function (MPHF)</a> is a function that assigns a unique hash (like the kind that can be stored in a URL segment) to every element of a set. I realized that this was the kind of function I needed to access the full storage potential of URLs.</p>
<p>Implementing this was a challenge at first, especially for nested component states. To implement an MPHF, you must first be able to enumerate the entire set of configurations you're trying to hash. That means that my framework demands a component-based MPHF that computes the state space of each component under the hood. I eventually found an approach that I liked and published it as the <b>MPHF Coordinate System</b> on <a ${_.pointAttr()} class="external" href="https://www.npmjs.com/package/mphf">NPM</a> and <a ${_.pointAttr()} class="external" href="https://github.com/kireji-app/mphf">GitHub</a>.</p>
<p>While the MPHF is component-based, it isn't a reactive web framework by itself. At some point along the way, I realized that the object-oriented data structure supporting my MPHF had a surprising amount in common with the MVC architecture I wanted to use to support the reactivity of my web framework. In fact, the two ended up sharing so many features that merging them was surprisingly straightforward.</p>
<p>This became a guiding principle for my framework: user interaction controllers double as subfunctions in the piecewise-defined MPHF and hashes double as easy-to-compare MVC models.</p>
<p>I dubbed these dual purpose components "parts". A part is a reusable component with an MVC controller and a hash range from 0 to k-1, where k is the cardinality of the component's state space. Like LEGOÂ® bricks, parts assemble arbitrarily into larger components. The result always provides a minimal perfect hash function over its state domain. Whether you assign a hash (which acts as the data model) to a controller or manipulate the controller directly (for example, via user interaction), views and hashes are always in sync.</p>
<p>I called the framework the <b>Kireji Web Framework</b> and reserved an <a ${_.pointAttr()} class="external" href="https://www.npmjs.com/package/kireji">NPM package</a> and <a ${_.pointAttr()} class="external" href="https://github.com/kireji-app/kireji">GitHub repo</a> for it, but I haven't populated it yet. First, I'm refining the methods and developer experience by creating and publishing a series of demo applications.</p>
<p>The applications include this very notebook (more details in <a ${_.pointAttr()} href=https://ejaugust.com/notes/1762063104>this note</a>) and a surrounding app ecosystem (read more in <a ${_.pointAttr()} href=https://ejaugust.com/notes/1762063947>this note</a>). You can get get a glimpse of component definition in the framework by looking at the <b>Demo App Ecosystem</b> on <a ${_.pointAttr()} class="external" href="https://github.com/kireji-app/demo">GitHub</a> and by exploring its components on <a ${_.pointAttr()} href="https://kireji.app">kireji.app</a>.</p>`