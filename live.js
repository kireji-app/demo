const
 protocolumns = {

  "default.columns": {
   // Cell values which shouldn't be inherited along the prototype chain.
   get() {
    return ({
     // .layout determines which rows to use as css stylesheets when rendering the current row as an element
     ".layout": { value: "" },
     // .children determines which rows to use as child nodes when rendering the current row as an element
     ".children": { value: "" },
     // The html, if set, overrides .children and just sets the inner HTML of the shadow to the given string
     ".html": { value: null },
     // The css, if set, overrides .layout and just sets a single stylesheet on the shadow to the given string
     ".css": { value: null },
     // The layout css determines what the current row's css is if the row is used as a css stylesheet
     "layout.css": { value: "" },
     // The view node is the node which gets it's render data from this row
     "view.node": { value: null },
     // The view tag is the html tag name to be used when this row is used as a child node
     "view.tag": { value: "tag-" },
     // This is the list of rows which directly inherit from this row
     ".rows": { value: {} },
     // This is the stylesheet object generated by this row
     "view.stylesheet": { value: null },
     // This is the index of the row if it is a set member belonging to it's parent row
     "index.int": { value: -1 }
    })
   }
  },

  "parent.row": { get() { return Object.getPrototypeOf(this) } },

  // Numerical values
  ".version": { value: 47 / 1000 },
  "next.version": { get() { return Math.trunc(this[".version"] * 1000 + 1) / 1000 } },

  "error404.html": { get() { return `<b><i>404</i></b>` } },

  // Booleans
  "debug.bool": { value: false },
  "true.bool": { value: true },
  "false.bool": { value: false },

  // URIs
  "name.uri": { value: "" },
  "path.uri": { get() { return (this["parent.row"]?.["path.uri"] ?? "") + this["name.uri"] + "/" } },

  /* Layouts
      Layouts are space-separated lists of row names which are to be treated as stylesheets. */
  "theme.layout": { value: "main-layout" },
  "sidebar.layout": { value: "sidebar" },
  "pill.layout": { value: "pill-layout" },
  "header.layout": { value: "header-layout" },
  "flex-spacer.layout": { value: "flex-spacer-layout" },
  "menu-buttons.layout": { value: "menu-buttons-layout" },

  /* Children
      Children is a space-separated list of row names which all are to be treated as child nodes. */
  "editor.children": { get() { return `${this["sidebar-open.bool"] ? 'sidebar ' : ''}header article` } },
  "sidebar.children": { get() { return `side-menu${this["inspector-open.bool"] ? ' inspector' : ''}` } },
  "inspector.children": { get() { return `header menu` } },
  "header.children": { value: "address flex-spacer version" },
  "zero.children": { value: "" },
  "menu-buttons.children": { value: "inspector-button flex-spacer account-button settings-button" },

  /* Commits
   A commit is a string representation of the set of differences between a row and it's parent row */
  "grey2.commit": { value: "grey.color=grey2.color" },
  "grey1.commit": { value: "grey.color=data:text/color,#344555" },
  "core.parts.commit": { value: "background.color=grey.color&.children=./editor.children&.layout=theme.layout&color.html=./background.color&sidebar-open.bool=true.bool" },
  "version.commit": { value: ".html=./.version&view.tag=./name.tag&pill-icon-right.bool=true.bool&.layout=pill.layout" },
  "address.commit": { value: ".html=./path.uri&view.tag=data:text/tag,addressbar-&.layout=pill.layout" },
  "sidebar.commit": { value: ".children=sidebar.children&view.tag=./name.tag&.layout=sidebar.layout&layout.css=sidebar.css" },
  "article.commit": { value: ".html=color.html&view.tag=./native.tag" },
  "header.commit": { value: ".children=header.children&view.tag=./native.tag&.layout=header.layout" },
  "grey-background.commit": { value: "background.color=grey.color&layout.css=background.css" },
  "inspector.commit": { value: "header.commit=inspector-header.commit&.children=zero.children&view.tag=./name.tag" },
  "inspector-header.commit": { value: ".html=data:text/html,Some panel" },
  "side-menu.commit": { value: ".children=menu-buttons.children&view.tag=./name.tag&.layout=menu-buttons.layout" },
  "bottom-menu.commit": { value: ".html=data:text/html,bottom&view.tag=data:text/tag,bottom-menu" },
  "main-layout.commit": { value: "layout.css=main-layout.css" },
  "hide-sidebar.commit": { value: "sidebar-open.bool=false.bool" },
  "open-inspector.commit": { value: "inspector-open.bool=true.bool" },
  "lighten-background.commit": { value: "background.color=light-background.color" },
  "pill-layout.commit": { value: 'layout.css=pill.css' },
  "header-layout.commit": { value: 'layout.css=header.css' },
  "flex-spacer.commit": { value: '.layout=flex-spacer.layout&view.tag=./name.tag' },
  "flex-spacer-layout.commit": { value: 'layout.css=flex-spacer.css' },
  "next-version.commit": { value: '.version=https://core.parts/next.version' },
  "button.commit": { value: "view.tag=./name.tag" },
  "menu-buttons-layout.commit": { value: "layout.css=menu-buttons.css" },
  "error404.commit": { value: '.css=error404.css&.html=error404.html' },
  "inspector-button.commit": { value: '.html=data:text/html,Inspector' },
  "account-button.commit": { value: '.html=data:text/html,User' },
  "settings-button.commit": { value: '.html=data:text/html,Settings' },

  // CSS tokens
  "sidebar-width.length": { value: "42px" },
  "grey2.color": { value: "#444444" },
  "grey.color": { value: "#333445" },
  "light-background.color": { get() { return '#' + this["background.color"].match(/[^#]{2}/g).map(s => Math.trunc((1 - (1 - parseInt(s, 16) / 255) * 0.5) * 255).toString(16)).join('') } },
  "background.color": { value: "tomato" },

  // CSS
  "error404.css": { get() { return `:host { background: magenta }` } },
  "menu-buttons.css": { get() { return `:host { display: flex; flex-flow: column nowrap; gap: 4px; padding: 4px; } tag- { height: auto !important; aspect-ratio: 1 / 1; }` } },
  "background.css": { get() { return `:host { color: white; padding: 12px; background: ${this["background.color"]} }` } },
  "pill.css": { get() { return `:host::${this["pill-icon-right.bool"] ? 'after' : 'before'} { content: 'ⓘ'; padding: 5px; border-radius: 50%; background: ${this["light-background.color"]}; margin-${this["pill-icon-right.bool"] ? 'left' : 'right'}: 8px; } :host { ${this["pill-icon-right.bool"] ? 'text-align: right; ' : ''}margin: 7px; display: inline-block; line-height: 24px; padding: 5px; color: white; border-radius: 16px; background: ${this["background.color"]}}` } },
  "header.css": { get() { return `:host { display: flex; flex-flow: row nowrap; background: ${this["branch.fn"]("lighten-background")["light-background.color"]}}` } },
  "flex-spacer.css": { value: `:host { flex: 1 1 }` },
  "sidebar.css": {
   get() {
    const inspectorOpen = this["inspector-open.bool"], sidebarWidth = this["sidebar-width.length"]
    return `
    :host {
     color: ${this["background.color"]};
     background: ${this["light-background.color"]};
     display: grid;
     grid-template: "b${inspectorOpen ? ' i' : ''}" 1fr / ${sidebarWidth} ${inspectorOpen ? '1fr' : ''};
    }
    side-menu { grid-area: b }
    ${inspectorOpen ? `inspector- { grid-area: i; background: ${this["branch.fn"]("lighten-background")["light-background.color"]} }` : ''}`
   }
  },
  "main-layout.css": {
   get() {
    const {
     "sidebar-open.bool": sidebarOpen,
     "inspector-open.bool": inspectorOpen,
     "sidebar-width.length": sidebarWidth
    } = this
    return `
   :host {
    --system-ui: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font: 13px var(--system-ui);
    margin: 0;
    padding: 0;
    display: grid;
    grid-template: 
     "${sidebarOpen ? 'h ' : ''}h" 48px
     "${sidebarOpen ? 's ' : ''}c" auto / ${sidebarOpen ? `${inspectorOpen ? '2' : ''}${sidebarWidth} ` : ''}1fr;
   }
   ${sidebarOpen ? "sidebar- { grid-area: s }" : ""}
   header { grid-area: h }
   article { grid-area: c; margin: 24px }`
   }
  },

  // HTML tag names
  "native.tag": {
   get() {

    const name = this["name.uri"]

    if (!name || !/^[a-zA-Z]+$/.test(name))
     throw RangeError(`Error: name "${name}" is not a native tagname.`)

    return name
   }
  },
  "name.tag": {
   get() {

    const
     name = this["name.uri"].replaceAll(/[^a-zA-Z0-9]+/g, '-'),
     tag = name + (name.includes('-') ? '' : '-')

    return tag
   }
  },

  /* Tests
      A test is a linked list item whose string represents a single instruction
      test.fn plays the linked list as a function block starting from a given named instruction and waiting the given amount of time
  */
  "sidebar.test": { value: " insert hide-sidebar grey1 100" },
  "grey1.test": { value: "sidebar insert grey1 grey2 1000" },
  "grey2.test": { value: "grey1 replaceWith grey2 lighten" },
  "lighten.test": { value: " insert next-version removed1" },
  "removed1.test": { value: "grey2 remove  inspect" },
  "inspect.test": { value: "lighten insert open-inspector addressbarFocus" },
  "addressbarFocus.test": { value: "lighten replaceWith address sidebarFocus" },
  "sidebarFocus.test": { value: "addressbarFocus replaceWith sidebar removed2" },
  "removed2.test": { value: "sidebarFocus remove  removed3 200" },
  "removed3.test": { value: "inspect remove  removed4 200" },
  "removed4.test": { value: "sidebar remove  sidebar 2000" },
  "test.fn": {
   get() {
    return (name, o) => {

     if (name === undefined) {
      name = 'sidebar'
      o = { "": protorow }
     }

     const [src, fn, str, n2, t] = protorow[`${name}.test`].split(' ')

     setTimeout(() => {
      // console.groupCollapsed('test ' + name)
      o[name] = o[src][fn + '.fn'](str || undefined)
      // console.log(name, Object.getOwnPropertyDescriptors(o[name]))
      protorow["render.fn"]()
      // console.groupEnd()
      this["test.fn"](n2, o)
     }, parseInt(t || 2000))
    }
   }
  },

  // Functions
  "render.fn": {
   // Re/populates this row's nodes and stylesheets
   get() {
    return () => {

     if (this["view.stylesheet"] !== null)
      this["view.stylesheet"].replaceSync(this["layout.css"])

     if (this["view.node"] !== null) {

      const
       showAttributes = this["debug.bool"],
       { shadowRoot } = this["view.node"]

      if (showAttributes)
       shadowRoot.host.setAttribute('data-path', this["path.uri"])

      layouts: {

       const
        rawCSS = this[".css"],
        stylesheets = shadowRoot.adoptedStyleSheets,
        existingSheets = [...stylesheets],
        existingSheetRows = existingSheets.map(sheet => sheet.row)

       if (rawCSS !== null) {

        console.warn('putting own css', rawCSS, this["name.uri"])

        let singleSheet = existingSheets[0];

        if (existingSheetRows.length !== 1 || singleSheet !== this) {
         for (const existingSheetRow of existingSheetRows) {
          existingSheetRow?.["remove.fn"]()
          stylesheets.pop()
         }
         singleSheet = new CSSStyleSheet()
         singleSheet.row = this
         stylesheets.push(singleSheet)
        }

        console.log(singleSheet)
        singleSheet.replaceSync(rawCSS)
       } else {

        const
         layout = this[".layout"],
         incomingSheetNames = layout === '' ? [] : layout.split(' ')

        if (showAttributes)
         shadowRoot.host.setAttribute('data-layout', layout)

        let i = -1

        while (existingSheetRows.length && incomingSheetNames.length) {

         i++

         const
          existingSheetRow = existingSheetRows.shift(),
          existingSheetName = existingSheetRow?.["name.uri"],
          incomingSheetName = incomingSheetNames.shift()

         if (existingSheetName === incomingSheetName)
          continue

         const existingIndex = existingSheetRows.findIndex(row => row["name.uri"] === incomingSheetName)

         let stylesheet

         if (existingIndex === -1) {
          stylesheet = new CSSStyleSheet()
          stylesheet.row = this["branch.fn"](incomingSheetName, { ["view.stylesheet"]: { value: stylesheet } })
         } else {
          const stylesheetIndex = i + existingIndex + 1
          stylesheet = stylesheets[stylesheetIndex]
          stylesheets.splice(stylesheetIndex, 1)
          existingSheetRows.splice(existingIndex, 1)
         }

         stylesheets.splice(i, 0, stylesheet)

         if (incomingSheetNames.some(name => name === existingSheetName)) {
          existingSheetRows.unshift(existingSheetRow)
          continue
         }

         stylesheets.splice(i + 1, 1)
        }

        if (existingSheetRows.length)
         existingSheetRows.forEach(() => stylesheets.pop())
        else if (incomingSheetNames.length)
         for (const incomingSheetName of incomingSheetNames) {
          const stylesheet = new CSSStyleSheet()
          stylesheet.row = this["branch.fn"](incomingSheetName, { ["view.stylesheet"]: { value: stylesheet } })
          stylesheets.push(stylesheet)
         }
       }
      }

      children: {

       const
        innerHTML = this[".html"],
        path = this["path.uri"]

       if (innerHTML !== null) {

        //  console.warn(`Warning: no garbage removal of .rows was done before innerHTML set on ${this["path.uri"]}`)

        if (shadowRoot.innerHTML != innerHTML)
         shadowRoot.innerHTML = innerHTML

        if (showAttributes && shadowRoot.host.getAttribute('data-path') != path)
         shadowRoot.host.setAttribute('data-path', path)
       } else {

        const
         createNode = (name, index = -1) => {

          let node = this[".rows"][name]?.[".rows"][index]?.["view.node"];

          const
           nameRow = this["branch.fn"](name),
           childRow = nameRow["branch.fn"](index, { "view.node": { get() { return node } } }),
           children = shadowRoot.children

          if (!node) {
           node ??= document.createElement(childRow["view.tag"])
           node.row = childRow

           if (showAttributes)
            node.setAttribute('data-name', name)

           try { node.attachShadow({ mode: 'open' }) }
           catch (e) { throw new Error(`Error: cannot attach shadow to <${childRow["view.tag"]}>. (creating node "${name}" at [${index}] using row "${this["name.uri"]}")`) }
          }

          if (index !== -1 && index < children.length)
           shadowRoot.insertBefore(node, children[index])
          else
           shadowRoot.appendChild(node)
         },
         incomingManifest = this[".children"],
         children = shadowRoot.children,
         existingNodes = [...children],
         existingIndexRows = existingNodes.map(node => node.row),
         existingNameRows = existingIndexRows.map(row => row["parent.row"]),
         existingNames = existingNameRows.map(row => row["name.uri"]),
         existingManifest = existingNames.join(' ');

        if (existingManifest !== incomingManifest) {
         const incomingNames = incomingManifest === '' ? [] : incomingManifest.split(' ')

         let i = -1, log = `SCAN LOG => ${this["path.uri"]}`

         while (existingNames.length && incomingNames.length) {

          const
           existingName = existingNames.shift(),
           incomingName = incomingNames.shift();

          i++

          log += `\n\t [${i.toString(10).padStart(3, '0')}] ${existingName} vs. ${incomingName}`

          if (existingName !== incomingName) {

           log += `\n\t     | - Remove ${existingName}`

           const
            existingIndexRow = existingIndexRows.shift(),
            existingNameRow = existingNameRows.shift(),
            existingNode = existingNodes.shift()

           existingNode.remove()
           existingIndexRow["remove.fn"]()

           if (existingNameRow["count.int"] === 0)
            existingNameRow["remove.fn"]()

           log += `\n\t     | - Add ${incomingName}`

           createNode(incomingName, i)

          }
         }

         existingNames.forEach((existingName, ii) => {
          log += `\n\t [${(i + ii + 1).toString(10).padStart(3, '0')}] ${existingName} vs. ∅`
          log += `\n\t     | - Remove ${existingName}`

          const
           existingIndexRow = existingIndexRows.shift(),
           existingNameRow = existingNameRows.shift(),
           existingNode = existingNodes.shift()

          existingNode.remove()
          existingIndexRow["remove.fn"]()

          if (existingNameRow["count.int"] === 0)
           existingNameRow["remove.fn"]()
         })

         incomingNames.forEach((incomingName, ii) => {
          log += `\n\t [${(i + ii + 1).toString(10).padStart(3, '0')}] ∅ vs. ${incomingName}`
          log += `\n\t     | - Add ${incomingName}`

          createNode(incomingName, i + ii + 1)
         })

         // console.log(log)
        }
       }

      }
     }

     Object.values(this[".rows"]).forEach(row => row["render.fn"]())
    }
   }
  },
  "branch.fn": {
   get() {
    return (name, inputColumns) => {

     if (name in this[".rows"]) {
      //console.info('uncaching ' + name, this["path.uri"], 'returning ' + this[".rows"][name]["path.uri"])
      return this[".rows"][name]
     }

     const
      isIndex = !isNaN(name),
      description = { ... this["default.columns"] },
      commit = isIndex ? `index.int=data:math/integer,${name}&view.tag&.layout&.html&.children&.css` : name + ".commit" in this ? this[name + ".commit"] : this["error404.commit"]

     if (!isIndex && !(name + ".commit" in this))
      console.error('404: commit not found "' + name + '"')

     for (const [key, ref] of (commit ? commit.split('&') : []).map(a => a ? a.split('=') : [])) {

      if (ref === undefined) {
       description[key] = { get() { return this["parent.row"][key] } }
       continue
      }

      if (ref.startsWith('data:')) {
       // TODO: datum should not just be string. It should be parsed by creating a parsing node and giving it the datauri and retrieving the value
       const datum = ref.slice(ref.indexOf(',') + 1)
       description[key] = { get() { return datum } }
       continue
      }

      if (ref.startsWith('https://')) {
       const
        subpaths = ref.slice(8).split('/'),
        subkey = subpaths.pop()


       if (!subkey)
        throw new RangeError(`Error: absolute cell reference must include a file name. Get reference to entire row not yet supported. (on ${this["path.uri"]}, adding ${ref})`)


       description[key] = {
        get() {

         let row = protorow

         for (const subpath of subpaths)
          row = row["branch.fn"](subpath)

         // console.warn(`absolute cell ${row["path.uri"]}`)

         return row[subkey]
        }
       }
       continue
      }

      let
       levels = 1,
       subkey = ref

      if (subkey.startsWith('./')) {
       subkey = subkey.slice(2)
       levels = 0
      } else while (subkey.startsWith('../')) {
       subkey = subkey.slice(3)
       levels++
      }

      description[key] = {
       get() {

        let row = this

        for (let i = 0; i < levels; i++) {

         row = row["parent.row"]

         if (row === null)
          throw new RangeError(`Error: relative reference to row which is beyond protorow ${ref})`)
        }

        // console.log('relative cell', row["path.uri"] + subkey)

        return row[subkey]
       }
      }
     }

     return this[".rows"][name] = Object.create(this, Object.assign(description, inputColumns, {
      "context.uri": { value: "context.uri instance.uri name.uri .commit" },
      "instance.uri": { value: Object.keys(description).join(' ') },
      "name.uri": { value: name },
      ".commit": { value: commit }
     }))
    }
   }
  },
  "donate.fn": {
   get() {
    return (child, parent, name = child["name.uri"]) => {
     delete this[".rows"][name]
     parent[".rows"][name] = child
     Object.setPrototypeOf(child, parent)
     // child["render.fn"]()
    };
   },
  },
  "insert.fn": {
   get() {
    return name => {

     const
      row = this["branch.fn"](name),
      rows = this[".rows"]

     for (const subkey in rows)
      if (rows[subkey] !== row)
       this["donate.fn"](rows[subkey], row, subkey)

     return row
    }
   }
  },
  "remove.fn": {
   get() {
    return () => {

     if (this === protorow)
      throw new Error("Error: Attempted to remove protorow.")

     const
      parent = this["parent.row"],
      rows = this[".rows"]

     delete parent[".rows"][this["name.uri"]]

     for (const subkey in rows)
      this["donate.fn"](rows[subkey], parent, subkey)

     return parent
    }
   }
  },
  "replaceWith.fn": {
   get() {
    return name => {

     if (this === protorow)
      return this["insert.fn"](name)

     const
      parent = this["parent.row"],
      row = parent["branch.fn"](name),
      rows = this[".rows"]

     delete parent[".rows"][this["name.uri"]]

     for (const subkey in rows)
      this["donate.fn"](rows[subkey], row, subkey)

     return row
    }
   }
  },
  "boot.fn": {
   get() {
    return (hostname, viewNode) => {
     // console.groupCollapsed('boot')
     viewNode.attachShadow({ mode: 'open' });
     (viewNode.row = this["branch.fn"](hostname, { "view.node": { value: viewNode } }))["render.fn"]();
     // console.groupEnd()
    }
   }
  }
 },
 protorow = Object.create(null, Object.assign(protocolumns, protocolumns["default.columns"].get()))

// Prepare the operating system
onload = () => {
 protorow["boot.fn"](location.host.slice(location.host.startsWith('dev.') ? 4 : 0), document.body)
 protorow["test.fn"]()
}

// TODO: ServiceWorker