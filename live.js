const
 protocolumns = {

  "default.columns": {
   // Cell values which shouldn't be inherited along the prototype chain.
   get() {
    return ({
     // .layout determines which rows to use as css stylesheets when rendering the current row as an element
     ".layout": { value: "" },
     // .children determines which rows to use as child nodes when rendering the current row as an element
     ".children": { value: "" },
     // The inner html, if set, overrides .children and just sets the inner HTML of the shadow to the given string
     "inner.html": { value: null },
     // The layout css determines what the current row's css is if the row is used as a css stylesheet
     "layout.css": { value: "" },
     // The view node is the node which gets it's render data from this row
     "view.node": { value: null },
     // The view tag is the html tag name to be used when this row is used as a child node
     "view.tag": { value: "tag-" },
     // This is the list of rows which directly inherit from this row
     ".rows": { value: {} },
     // This is the stylesheet object generated by this row
     "view.stylesheet": { value: null },
     // This is the index of the row if it is a set member belonging to it's parent row
     "index.int": { value: -1 }
    })
   }
  },

  "parent.row": { get() { return Object.getPrototypeOf(this) } },

  // Numerical values
  ".version": { value: 46 / 1000 },
  "next.version": { get() { return Math.trunc(this[".version"] * 1000 + 1) / 1000 } },

  // Booleans
  "debug.bool": { value: false },
  "true.bool": { value: true },
  "false.bool": { value: false },

  // URIs
  "name.uri": { value: "" },
  "path.uri": { get() { return (this["parent.row"]?.["path.uri"] ?? "") + this["name.uri"] + "/" } },

  /* Layouts
      Layouts are space-separated lists of row names which are to be treated as stylesheets. */
  "theme.layout": { value: "main-layout" },
  "sidebar.layout": { value: "sidebar" },
  "addressbar.layout": { value: "addressbar-layout" },
  "header.layout": { value: "header-layout" },
  "flex-spacer.layout": { value: "flex-spacer-layout" },

  /* Children
      Children is a space-separated list of row names which all are to be treated as child nodes. */
  "editor.children": { get() { return `${this["sidebar-open.bool"] ? 'sidebar ' : ''}header article` } },
  "sidebar.children": { get() { return `side-menu inspector` } },
  "inspector.children": { get() { return `header menu` } },
  "header.children": { value: "address flex-spacer version" },
  "zero.children": { value: "" },
  "menu-buttons.children": { value: "button button button button button" },

  /* Commits
   A commit is a string representation of the set of differences between a row and it's parent row */
  "grey2.commit": { value: "grey.color=grey2.color" },
  "grey1.commit": { value: "grey.color=data:text/color,#344555" },
  "core.parts.commit": { value: "background.color=grey.color&.children=editor.children&.layout=theme.layout&color.html=./background.color" },
  "version.commit": { value: "inner.html=./.version&view.tag=./name.tag" },
  "address.commit": { value: "inner.html=./path.uri&view.tag=data:text/tag,addressbar-&.layout=addressbar.layout" },
  "sidebar.commit": { value: ".children=sidebar.children&view.tag=./name.tag&.layout=sidebar.layout&layout.css=sidebar.css" },
  "article.commit": { value: "inner.html=color.html&view.tag=./native.tag" },
  "header.commit": { value: ".children=header.children&view.tag=./native.tag&.layout=header.layout" },
  "grey-background.commit": { value: "background.color=grey.color&layout.css=background.css" },
  "inspector.commit": { value: "header.commit=inspector-header.commit&.children=zero.children&view.tag=./name.tag" },
  "inspector-header.commit": { value: "inner.html=data:text/html,Some panel" },
  "side-menu.commit": { value: ".children=menu-buttons.children&view.tag=./name.tag" },
  "bottom-menu.commit": { value: "inner.html=data:text/html,bottom&view.tag=data:text/tag,bottom-menu" },
  "main-layout.commit": { value: "layout.css=main-layout.css" },
  "open-sidebar.commit": { value: "sidebar-open.bool=true.bool" },
  "open-inspector.commit": { value: "inspector-open.bool=true.bool" },
  "lighten-background.commit": { value: "background.color=light-background.color" },
  "addressbar-layout.commit": { value: 'layout.css=addressbar.css' },
  "header-layout.commit": { value: 'layout.css=header.css' },
  "flex-spacer.commit": { value: '.layout=flex-spacer.layout&view.tag=./name.tag' },
  "flex-spacer-layout.commit": { value: 'layout.css=flex-spacer.css' },
  "next-version.commit": { value: '.version=https://core.parts/next.version' },
  "button.commit": { value: "" },

  // CSS color tokens
  "grey2.color": { value: "#444444" },
  "grey.color": { value: "#333445" },
  "light-background.color": { get() { return '#' + this["background.color"].match(/[^#]{2}/g).map(s => Math.trunc((1 - (1 - parseInt(s, 16) / 255) * 0.5) * 255).toString(16)).join('') } },
  "background.color": { value: "tomato" },

  // CSS
  "background.css": { get() { return `:host { color: white; padding: 12px; background: ${this["background.color"]} }` } },
  "addressbar.css": { get() { return `:host::before { content: 'ⓘ'; padding: 5px; border-radius: 50%; background: ${this["light-background.color"]}; margin-right: 8px; } :host { min-width: 50%; margin: 7px; display: inline-block; line-height: 24px; padding: 5px; color: white; border-radius: 16px; background: ${this["background.color"]}}` } },
  "header.css": { get() { return `:host { display: flex; flex-flow: row nowrap; background: ${this["beget.fn"]("lighten-background")["light-background.color"]}}` } },
  "flex-spacer.css": { value: `:host { flex: 1 1 }` },
  "sidebar.css": {
   get() {
    const inspectorOpen = this["inspector-open.bool"];
    return `
    :host {
     color: ${this["background.color"]};
     background: ${this["light-background.color"]};
     display: grid;
     grid-template: "b${inspectorOpen ? ' i' : ''}" 1fr / 56px ${inspectorOpen ? '1fr' : ''};
    }
    side-menu { grid-area: t }
    ${inspectorOpen ? `inspector- { grid-area: i; background: ${this["beget.fn"]("lighten-background")["light-background.color"]} }` : ''}`
   }
  },
  "main-layout.css": {
   get() {
    const sidebarOpen = this["sidebar-open.bool"]
    return `
   :host {
    --system-ui: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font: 13px var(--system-ui);
    margin: 0;
    padding: 0;
    display: grid;
    grid-template: 
     "${sidebarOpen ? 'h ' : ''}h" 48px
     "${sidebarOpen ? 's ' : ''}c" auto / ${sidebarOpen ? `${(this["inspector-open.bool"] ? '2' : '')}56px ` : ''}1fr;
   }
   sidebar- { grid-area: s }
   header { grid-area: h }
   article { grid-area: c; margin: 24px }`
   }
  },

  // HTML tag names
  "h1.tag": { value: "h1" },
  "native.tag": {
   get() {

    const name = this["name.uri"]

    if (!name || !/^[a-zA-Z]+$/.test(name))
     throw RangeError(`Error: name "${name}" is not a native tagname.`)

    return name
   }
  },
  "name.tag": {
   get() {

    const
     name = this["name.uri"].replaceAll(/[^a-zA-Z0-9]+/g, '-'),
     tag = name + (name.includes('-') ? '' : '-')

    return tag
   }
  },

  /* Tests
      A test is a linked list item whose string represents a single instruction
      test.fn plays the linked list as a function block starting from a given named instruction and waiting the given amount of time
  */
  "sidebar.test": { value: " insert open-sidebar grey1 100" },
  "grey1.test": { value: "sidebar insert grey1 grey2 1000" },
  "grey2.test": { value: "grey1 replaceWith grey2 lighten" },
  "lighten.test": { value: " insert next-version removed1" },
  "removed1.test": { value: "grey2 remove  inspect" },
  "inspect.test": { value: "lighten insert open-inspector addressbarFocus" },
  "addressbarFocus.test": { value: "lighten replaceWith address sidebarFocus" },
  "sidebarFocus.test": { value: "addressbarFocus replaceWith sidebar removed2" },
  "removed2.test": { value: "sidebarFocus remove  removed3 200" },
  "removed3.test": { value: "inspect remove  removed4 200" },
  "removed4.test": { value: "sidebar remove  sidebar 2000" },

  // Functions
  "test.fn": {
   get() {
    return (name, o) => {

     if (name === undefined) {
      name = 'sidebar'
      o = { "": protorow }
     }

     const [src, fn, str, n2, t] = protorow[`${name}.test`].split(' ')

     setTimeout(() => {
      console.groupCollapsed('test ' + name)
      o[name] = o[src][fn + '.fn'](str || undefined)
      // console.log(name, Object.getOwnPropertyDescriptors(o[name]))
      protorow["render.fn"]()
      console.groupEnd()
      this["test.fn"](n2, o)
     }, parseInt(t || 2000))
    }
   }
  },
  "render.fn": {
   // Re/populates this row's nodes and stylesheets
   get() {
    return () => {

     if (this["view.stylesheet"] !== null)
      this["view.stylesheet"].replaceSync(this["layout.css"])

     if (this["view.node"] !== null) {

      const
       showAttributes = this["debug.bool"],
       { shadowRoot } = this["view.node"]

      if (showAttributes)
       shadowRoot.host.setAttribute('data-path', this["path.uri"])

      layouts: {

       const
        layout = this[".layout"],
        incomingLayoutUris = layout === '' ? [] : layout.split(' ')

       const
        stylesheets = shadowRoot.adoptedStyleSheets,
        existingSheets = [...stylesheets],
        existingSheetRows = existingSheets.map(sheet => sheet.row)

       if (showAttributes)
        shadowRoot.host.setAttribute('data-layout', layout)

       let i = -1

       while (existingSheetRows.length && incomingLayoutUris.length) {

        i++

        const
         existingSheetRow = existingSheetRows.shift(),
         existingSheetName = existingSheetRow["name.uri"],
         incomingSheetName = incomingLayoutUris.shift()

        if (existingSheetName === incomingSheetName)
         continue

        const existingIndex = existingSheetRows.findIndex(row => row["name.uri"] === incomingSheetName)

        let stylesheet

        if (existingIndex === -1) {
         stylesheet = new CSSStyleSheet()
         stylesheet.row = this["beget.fn"](incomingSheetName, { ["view.stylesheet"]: { value: stylesheet } })
        } else {
         const stylesheetIndex = i + existingIndex + 1
         stylesheet = stylesheets[stylesheetIndex]
         stylesheets.splice(stylesheetIndex, 1)
         existingSheetRows.splice(existingIndex, 1)
        }

        stylesheets.splice(i, 0, stylesheet)

        if (incomingLayoutUris.some(name => name === existingSheetName)) {
         existingSheetRows.unshift(existingSheetRow)
         continue
        }

        stylesheets.splice(i + 1, 1)
       }

       if (existingSheetRows.length)
        existingSheetRows.forEach(() => stylesheets.pop())
       else if (incomingLayoutUris.length)
        for (const incomingSheetName of incomingLayoutUris) {
         const stylesheet = new CSSStyleSheet()
         stylesheet.row = this["beget.fn"](incomingSheetName, { ["view.stylesheet"]: { value: stylesheet } })
         stylesheets.push(stylesheet)
        }
      }

      children: {

       const
        innerHTML = this["inner.html"],
        path = this["path.uri"],
        createNode = (name, index = -1) => {

         let node = this[".rows"][name]?.[".rows"][index]?.["view.node"];

         const
          nameRow = this["beget.fn"](name),
          childRow = nameRow["beget.fn"](index, { "view.node": { get() { return node } } }),
          children = shadowRoot.children

         if (!node) {
          node ??= document.createElement(childRow["view.tag"])
          node.row = childRow

          if (showAttributes)
           node.setAttribute('data-name', name)

          try { node.attachShadow({ mode: 'open' }) }
          catch (e) { throw new Error(`Error: cannot attach shadow to <${childRow["view.tag"]}>. (creating node "${name}" at [${index}] using row "${this["name.uri"]}")`) }
         }

         if (index !== -1 && index < children.length)
          shadowRoot.insertBefore(node, children[index])
         else
          shadowRoot.appendChild(node)
        }

       if (innerHTML !== null) {

        console.warn(`Warning: no garbage removal of .rows was done before innerHTML set on ${this["path.uri"]}`)

        if (shadowRoot.innerHTML != innerHTML)
         shadowRoot.innerHTML = innerHTML

        if (showAttributes && shadowRoot.host.getAttribute('data-path') != path)
         shadowRoot.host.setAttribute('data-path', path)
       } else {

        const
         incomingManifest = this[".children"],
         children = shadowRoot.children,
         existingNodes = [...children],
         existingIndexRows = existingNodes.map(node => node.row),
         existingNameRows = existingIndexRows.map(row => row["parent.row"]),
         existingNames = existingNameRows.map(row => row["name.uri"]),
         existingManifest = existingNames.join(' ');

        if (existingManifest !== incomingManifest) {
         const incomingNames = incomingManifest === '' ? [] : incomingManifest.split(' ')

         let i = -1, log = `SCAN LOG => ${this["path.uri"]}`

         while (existingNames.length && incomingNames.length) {

          const
           existingName = existingNames.shift(),
           incomingName = incomingNames.shift();

          i++

          log += `\n\t [${i.toString(10).padStart(3, '0')}] ${existingName} vs. ${incomingName}`

          if (existingName !== incomingName) {

           log += `\n\t     | - Remove ${existingName}`

           const
            existingIndexRow = existingIndexRows.shift(),
            existingNameRow = existingNameRows.shift(),
            existingNode = existingNodes.shift()

           existingNode.remove()
           existingIndexRow["remove.fn"]()

           if (existingNameRow["count.int"] === 0)
            existingNameRow["remove.fn"]()

           log += `\n\t     | - Add ${incomingName}`

           createNode(incomingName, i)

          }

          /*

           if (existingNodeName !== incomingNodeName) {
 
            const existingIndex = existingNodeRows.findIndex(row => row["name.uri"] === incomingNodeName)
 
            log += `\n\t\tDIFFERENT | Existing index: ${existingIndex}`
 
            if (existingIndex === -1) {
             log += `\n\t\t\tCreating ${incomingNodeName} @ [${i}]...`
             createNode(incomingNodeName, i)
            } else {
             log += `\n\t\t\tRepositioning ${incomingNodeName} [${i + existingIndex + 1}] => [${i}]`
             shadowRoot.insertBefore(children[i + existingIndex + 1], children[i])
             existingNodeRows.splice(existingIndex, 1)
             log += `\n\t\t\tSplicing from existing.\n\t\t\t\tnow existing: ${existingNodeRows.map(row => row["name.uri"]).join(' ')}`
            }
 
            if (incomingNames.some(name => name === existingNodeName)) {
             existingNodeRows.unshift(existingNodeRow)
             log += `\n\t\tThere is an incoming child named ${existingNodeName} so we'll keep it.\n\t\t\texisting: ${existingNodeRows.map(row => row["name.uri"]).join(' ')}\n\t\tCONTINUE...`
             continue
            }
 
            const removedNode = children[i + 1]
            removedNode.remove()
            removedNode.row["remove.fn"]()
            log += `\n\t\tRemoving node from children and row from node list.\n\t\t\t\tnow children: ${[...children].map(node => node.row["name.uri"]).join(' ')}\n\t\tCONTINUE...`
           }
          */
         }

         existingNames.forEach((existingName, ii) => {
          log += `\n\t [${(i + ii + 1).toString(10).padStart(3, '0')}] ${existingName} vs. ∅`
          log += `\n\t     | - Remove ${existingName}`

          const
           existingIndexRow = existingIndexRows.shift(),
           existingNameRow = existingNameRows.shift(),
           existingNode = existingNodes.shift()

          existingNode.remove()
          existingIndexRow["remove.fn"]()

          if (existingNameRow["count.int"] === 0)
           existingNameRow["remove.fn"]()
         })

         incomingNames.forEach((incomingName, ii) => {
          log += `\n\t [${(i + ii + 1).toString(10).padStart(3, '0')}] ∅ vs. ${incomingName}`
          log += `\n\t     | - Add ${incomingName}`

          createNode(incomingName, i + ii + 1)
         })

         console.log(log)
        }
       }

      }
     }

     Object.values(this[".rows"]).forEach(row => row["render.fn"]())
    }
   }
  },
  "beget.fn": {
   get() {
    return (name, inputColumns) => {

     if (name in this[".rows"]) {
      //console.info('uncaching ' + name, this["path.uri"], 'returning ' + this[".rows"][name]["path.uri"])
      return this[".rows"][name]
     }

     const
      isIndex = !isNaN(name),
      description = { ... this["default.columns"] },
      commit = isIndex ? `index.int=data:math/integer,${name}&view.tag=view.tag&.layout=.layout&inner.html=inner.html&.children=.children` : this[name + ".commit"]

     if (!isIndex && !(name + ".commit" in this))
      throw new RangeError('Error: no commit called "' + name + '"')

     for (const [key, ref] of (commit ? commit.split('&') : []).map(a => a ? a.split('=') : [])) {

      if (ref.startsWith('data:')) {
       // TODO: datum should not just be string. It should be parsed by creating a parsing node and giving it the datauri and retrieving the value
       const datum = ref.slice(ref.indexOf(',') + 1)
       description[key] = { get() { return datum } }
       continue
      }

      if (ref.startsWith('https://')) {
       const
        subpaths = ref.slice(8).split('/'),
        subkey = subpaths.pop()


       if (!subkey)
        throw new RangeError(`Error: absolute cell reference must include a file name. Get reference to entire row not yet supported. (on ${this["path.uri"]}, adding ${ref})`)


       description[key] = {
        get() {

         let row = protorow

         for (const subpath of subpaths)
          row = row["beget.fn"](subpath)

         // console.warn(`absolute cell ${row["path.uri"]}`)

         return row[subkey]
        }
       }
       continue
      }

      let
       levels = 1,
       subkey = ref

      if (subkey.startsWith('./')) {
       subkey = subkey.slice(2)
       levels = 0
      } else while (subkey.startsWith('../')) {
       subkey = subkey.slice(3)
       levels++
      }

      description[key] = {
       get() {

        let row = this

        for (let i = 0; i < levels; i++) {

         row = row["parent.row"]

         if (row === null)
          throw new RangeError(`Error: relative reference to row which is beyond protorow ${ref})`)
        }

        // console.log('relative cell', row["path.uri"] + subkey)

        return row[subkey]
       }
      }
     }

     return this[".rows"][name] = Object.create(this, Object.assign(description, inputColumns, {
      "context.uri": { value: "context.uri instance.uri name.uri .commit" },
      "instance.uri": { value: Object.keys(description).join(' ') },
      "name.uri": { value: name },
      ".commit": { value: commit }
     }))
    }
   }
  },
  "donate.fn": {
   get() {
    return (child, parent, name = child["name.uri"]) => {
     delete this[".rows"][name]
     parent[".rows"][name] = child
     Object.setPrototypeOf(child, parent)
     // child["render.fn"]()
    };
   },
  },
  "insert.fn": {
   get() {
    return name => {

     const
      row = this["beget.fn"](name),
      rows = this[".rows"]

     for (const subkey in rows)
      if (rows[subkey] !== row)
       this["donate.fn"](rows[subkey], row, subkey)

     return row
    }
   }
  },
  "remove.fn": {
   get() {
    return () => {

     if (this === protorow)
      throw new Error("Error: Attempted to remove protorow.")

     const
      parent = this["parent.row"],
      rows = this[".rows"]

     delete parent[".rows"][this["name.uri"]]

     for (const subkey in rows)
      this["donate.fn"](rows[subkey], parent, subkey)

     return parent
    }
   }
  },
  "replaceWith.fn": {
   get() {
    return name => {

     if (this === protorow)
      return this["insert.fn"](name)

     const
      parent = this["parent.row"],
      row = parent["beget.fn"](name),
      rows = this[".rows"]

     delete parent[".rows"][this["name.uri"]]

     for (const subkey in rows)
      this["donate.fn"](rows[subkey], row, subkey)

     return row
    }
   }
  },
  "boot.fn": {
   get() {
    return (hostname, viewNode) => {
     console.groupCollapsed('boot')
     viewNode.attachShadow({ mode: 'open' });
     (viewNode.row = this["beget.fn"](hostname, { "view.node": { value: viewNode } }))["render.fn"]();
     console.groupEnd()
    }
   }
  }
 },
 protorow = Object.create(null, Object.assign(protocolumns, protocolumns["default.columns"].get()))

// Prepare the operating system
onload = () => {
 protorow["boot.fn"](location.host.slice(location.host.startsWith('dev.') ? 4 : 0), document.body)
 protorow["test.fn"]()
}

// TODO: ServiceWorker